import os
import random
import arxiv
import argparse
import asyncio
from datetime import datetime
from agents import Agent, function_tool, ModelSettings, Runner
from github import Github
from slugify import slugify


OUTPUT_DIR = "/app/web/output"
os.makedirs(OUTPUT_DIR, exist_ok=True)

GITHUB_TOKEN = os.getenv("GITHUB_TOKEN")
BLOG_REPO = os.getenv("BLOG_REPO")
BLOG_PATH = os.getenv("BLOG_PATH", "").strip("/")


@function_tool
def fetch_arxiv(field: str) -> str:
    """Fetches the ID, title, and abstract of a random recent ArXiv paper."""
    print(f"Fetching ArXiv paper for field: {field}")
    search = arxiv.Search(query=field, max_results=5,
                          sort_by=arxiv.SortCriterion.SubmittedDate)
    papers = list(search.results())
    if not papers:
        print(f"No recent papers found for '{field}'.")
        return f"No recent papers found for '{field}'."
    p = random.choice(papers)
    print(f"Fetched paper: {p.title}")
    return f"{p.entry_id}\n# {p.title}\n\n{p.summary}"


@function_tool
def summarize(text: str, summary_points: str) -> str:
    """Summarizes the given paper text focusing on the specified points."""
    prompt = f"Summarize the following text focusing on: {summary_points}\n\n{text}"
    # Implement your summarization logic here
    return "Summarized content based on the provided summary points."


@function_tool
def generate_filename(title: str) -> str:
    """Generates a short and descriptive filename from the title."""
    words = slugify(title).split("-")
    filename = "-".join(words[:5])  # Keep it between 2-5 words
    if not filename.endswith(".mdx"):
        filename += ".mdx"
    return filename


@function_tool
def generate_title(paper_title: str) -> str:
    """Creates a concise blog post title from the paper title."""
    # e.g. "New Coarse-to-Fine Detection"
    return f"{paper_title}"


BLOG_TEMPLATE = """---
title: '{title}'
description: 'Research summary of {title}'
authors: [agent]
tags: [research_summary, cybersecurity]
---
<!-- truncate -->

# Research summary of {title}

{body}

---
**Disclosure:** This summary was generated by an AI agent based on ArXiv paper‚Äôs metadata and abstract {paper_id}. {paper_link}
*Generated on {date}*
"""


@function_tool
def write_blog(
    title: str,
    body: str,
    paper_id: str,
    paper_link: str
) -> str:
    """Renders the MDX template with multiple tags."""
    today = datetime.utcnow().strftime("%Y-%m-%d")
    return BLOG_TEMPLATE.format(
        title=title,
        body=body,
        paper_id=paper_id,
        paper_link=paper_link,
        date=today
    )


@function_tool
def write_file(filename: str, content: str) -> str:
    """
    Persists `content` under OUTPUT_DIR/filename and returns the full path.
    """
    if not filename.endswith(".mdx"):
        filename += ".mdx"
    safe = content.replace("\x00", "")
    path = os.path.join(OUTPUT_DIR, filename)
    with open(path, "w", encoding="utf-8") as f:
        f.write(safe)
    print(f"File written to {path}")
    return path


@function_tool
def push_to_github(filename: str, content: str) -> str:
    """
    Pushes the given content to GitHub under BLOG_REPO/BLOG_PATH/filename
    and returns the HTTPS URL to the new file.
    """
    if not filename.endswith(".mdx"):
        filename += ".mdx"
    gh = Github(GITHUB_TOKEN)
    repo = gh.get_repo(BLOG_REPO)
    path = f"{BLOG_PATH}/{filename}"
    try:
        existing = repo.get_contents(path)
        repo.update_file(
            existing.path,
            f"Update blog post {filename}",
            content,
            existing.sha,
            branch="main"
        )
    except Exception:
        repo.create_file(
            path,
            f"Add blog post {filename}",
            content,
            branch="main"
        )
    return f"https://github.com/{BLOG_REPO}/{path}"

agent = Agent(
        name="ResearchBloggerAgent",
        instructions="""
    You are a research summarization agent. Follow these steps:
    1. Fetch a recent research paper related to the given field using 'fetch_arxiv'.
    2. Summarize the paper focusing on the specified summary points using 'summarize'.
    3. Generate a concise (between 2-5 words) filename using 'generate_filename' based on the paper title.
    4. Create a blog post concise (between 2-8 words) title using 'generate_title' based on the paper title.
    5. format the summary into a Markdown blog post with the style using 'write_blog' as mdx file.
    6. Return the generated the formatted Markdown content.
    7. Save the Markdown content to a file using 'write_file' with the name generated and return the file path.
    8. Push the file to GitHub using 'push_to_github' and return the URL.
    """,
        model="gpt-4o",
        tools=[fetch_arxiv, summarize, generate_filename,
               write_blog, write_file, push_to_github, generate_title],
        model_settings=ModelSettings(temperature=0.3),
    )

def _parse_args():
    p = argparse.ArgumentParser(
        description="Run ResearchBloggerAgent from the CLI"
    )
    p.add_argument("--field",          required=True, help="e.g. cybersecurity")
    p.add_argument("--summary_points", required=True, help="comma-separated, e.g. methods, results")
    p.add_argument("--style",          required=True, help="writing style, e.g. conversational, 400 words")
    return p.parse_args()

async def _run_cli():
    args = _parse_args()
    # **THIS** is the critical part: one single string
    prompt = (
        f"field={args.field};"
        f"summary_points={args.summary_points};"
        f"style={args.style}"
    )
    print("üß† Starting ResearchBloggerAgent with prompt:\n", prompt)
    try:
        result = await Runner.run(agent, prompt)
        # assume the last tool returns the GitHub URL or file path
        print("‚úÖ Agent finished. Output ‚Üí\n", result.final_output)
    except Exception as e:
        print("‚ùå Agent error:", e)
        raise

if __name__ == "__main__":
    asyncio.run(_run_cli())
